Описание языка Лисп
===================

Интерфейс
---------

После запуска интерпретатора появляется цикл REPL (read, eval, print loop):

* чтение выражения;
* вычисление значения выражения;
* печать результата вычислений;
* цикл продолжается сначала.

Условием остановки цикла является символ EOF (конец файла или потока ввода).

S-выражения
-----------

Выражением является или атом (последовательность букв и символов) или список из нуля или более выражений, которые разделены пустотами (пробелы или переводы строк) и заключены в круглые скобки.

Пример выражений:
::

   avr
   ()
   (a)
   (a b c)
   (a b (c) d)

Разновидностью атомов являются целые числа. Все остальные атомы называются символами.

Вычисление выражений
--------------------

Каждое правильное выражение имеет значение (возвращает значение).

Если выражение является числом, строкой, массивом, то оно возвращает само число.

Если выражение - список, то первый элемент списка - это оператор (функция), остальные - аргументы. При вычислении выражения сначала вычисляются аргументы, затем оператор (исключение составляют особые операторы, у которых другой порядок вычислений).

Типы объектов
-------------

Объекты могут быть числами - 10, 20, 0xff, символами - AB, списками(парами) - (1 2), строками - "123", массивами - #(1 1 1)

Примитивные операторы (функции)
-------------------------------

1. (quote x) (особый оператор) возвращает свой аргумент без вычисления. Сокращенная запись - 'x.
   ::

      > (quote a)
      A
      > 'a
      A
      > (quote (a b c))
      (A B C)

2. (atom x) если аргумент атом, то возвращает атом T (истина), иначе возвращает атом NIL эквивалентный пустому списку (), что означает ложь.
   ::

      > (atom 'a)
      T
      > (atom 10)
      T
      > (atom '(a b c))
      NIL
      > (atom '())
      T
      > (atom (atom 'a))
      T                 # функция внутри функции
      > (atom '(atom 'a))
      NIL           # цитирование отменяет вычисление, поэтому аргумент - список

3. (eq x y) возвращает T, если x и y - один и тот же атом (пустой список это тоже атом), иначе возвращает NIL.
   ::

      > (eq 'a 'a)
      T
      > (eq 'a 'b)
      NIL
      > (eq '() '())
      T

4. (car x) ожидает, что аргумент - список, возвращает первый элемент списка.
   ::

      > (car '(a b c))
      A

5. (cdr x) ожидает, что аргумент - список, возвращает все кроме первого элемента списка.
   ::

      > (cdr '(a b c))
      (B C)

6. (cons x y) ожидает, что аргумент y - список, возвращает список который содержит x, и продолжается с элементами y.
   ::

      > (cons 'a '(b c))
      (A B C)
      > (cons 'a (cons 'b (cons 'c '())))
      (A B C)
      > (cons '(a b) '(c d))
      ((A B) C D)

#. (cond (p1 e1) ... (pn en)) (особый оператор). Выражения p вычисляются до тех пор, пока не будет значение T (истина). Как только такое выражение найдено, то возвращается значение соответствующего выражения e как результат всего выражения cond.
   ::

      > (cond ((eq 'a 'b) 'first)
              ((atom 'a) 'second))
      SECOND

Комментарии
-----------

Комментарии идут после ; до конца строки:
::

   (defvar *global*) ; глобальная переменная
      
Лямбда выражения
----------------

Лямбда выражение - это анонимная (без имени) функция (lambda (p1 ... pn) e), где
p1 ... pn - это параметры функции, e - выражение.

Вызов функции - это следующее выражение:
::

   ((lambda (p1 ... pn) e) a1 ... an)

Сначала вычисляются все аргументы a1 ... an. Затем каждому параметру p1 ... pn ставится в соответствие вычисленное значение аргументов a1 ... an. После этого вычисляется выражение e, содержащее параметры, вместо которых будут подставлены их значения.
::

   > ((lambda (x) (cons x '(b))) 'a)
   (A B)
   > ((lambda (x y) (cons x (cdr y)))
     'z
     '(a b c))
   (Z B C)

Определение функций
-------------------

Новую функцию можно создать с помощью оператора defun:
::

    > (defun null (x)
         (eq x NIL))
    NULL  # имя новой функции
    > (null 'a)
    NIL
    > (null '())
    T

Функция может иметь строку документации:
::

   (defun null (x)
   "проверяет аргумент на пустое значение"
         (eq x NIL))

Функции для работы со списками
------------------------------

Для изменения списков служат функции rplaca и rplacd. Эти функции изменяют элементы car и cdr в паре. Первый аргумент должен быть парой. Второй - любой объект.
Возвращается измененная пара (объект не копируется):
::

   > (defvar list '(a b c))
   LIST
   > (rplaca list 1)
   (1 b c)
   > list
   (1 b c)
   > (rplacd list nil)
   (1)
   > list
   (1)

Глобальные переменные
---------------------

Глобальные переменные существуют все время работы. Они создаются с помощью функции defvar имя_переменной [значение] (особая форма). Значение может быть выражением:
::

   > (defvar a 10)
   A
   > A
   10

При отстутствии значения в переменную записывается значение NIL
::

   > (defvar a)
   A
   > A
   NIL

Установить значение переменной можно с помощью функции setq (особая форма). Если такой переменной не было то она создается.
::

   > (setq a 1)
   1
   > a
   1

Можно одной функцией установить значения нескольких переменных:
::

   (setq a 1 b 2 c 3)

Если переменная локальная (параметр функции), то setq ее модифицирует:
::

   > (defun test(x)
        (setq x 10)) ; модификация параметра

Арифметические операции
-----------------------
::

   > (+ 1 2 3 4)
   10
   > (- 10 1 2)
   7
   > (* 20 30 10)
   6000
   > (/ 10 2) ; только 2 параметра
   5

Сравнение по значению:
::

   > (equal 4 4)
   T
   > (equal 1 2)
   NIL
   > (equal '(1 2) '(a 2))
   NIL
   > (equal '(a b) ('a b))
   T
   > (equal '((1) (a b)) '((1) (a b)))
   T
   > (equal "abc" "abc")
   T
   > (equal #(1 1 'a) #(1 1 'a))
   T

Побитовое И (1 или более параметров):
::

   > (& 0xA1 1)
   1
   > (& 1 1 1)
   1

Побитовое ИЛИ (1 или более параметров):
::

   > (bitor 0xf 0 0xf0)
   255

Сдвиг влево (только 2 параметра):
::

   > (<< 1 2)
   8

Сдвиг вправо (только 2 параметра):
::

   > (>> 0xF0 8)
   15
	
Строки
------

Строки задаются в двойных кавычках:
::

   > (defvar str "abc")
   STR
   > str
   "abc"

Функция объединения строк (1 или более параметров):
::

   > (concat "abc " "cde")
   "abc cde"
   > (concat "abc")
   "abc"

Функция преобразования строки в символ:
::

   > (intern "A")
   A

Функция преобразования символа в строку:
::

   > (symbol-name 'abc)
   "ABC"
      
Массивы
-------

Массивы в виде константы задаются как:
::

   > #(1 2 3 4)
   #(1 2 3 4)

Создание пустого массива заданной длины:
::

   (make-array <имя массива> <размер>)
   (defvar arr (make-array 100)) ; массив из 100 элементов

Присвоение значения элементу массива (значением может быть любой объект):
::

   (seta <объект массив> <индекс> <объект значение>)
   > (seta 'arr 0 10) ; arr[0] = 10
   10
   > (seta 'arr 10 '(a b c)) ; arr[10] = (A B C)
   (A B C)

Чтение элемента массива:
::

   (aref <массив> <индекс>)
   > (aref 'arr 0)
   10

Индекс массива начинается с 0 и не может превышать размер.

Макросы
-------

Макрос задает шаблон для генерации выражения.
::
   
   (defmacro test (var val)
       (list 'defvar var val))

При вызове макроса сначала происходит вычисление тела макроса (развертывание макроса):
::

   (test abc 100) -> (defvar abc 100)

Затем получившееся выражение вычисляется:
::

   (defvar abc 100)
   ABC

Обратная кавычка (работает не обязательно в макросах) вычисляется как обычная кавычка (цитирование работает со всеми типами объектов):
::

   > `(a b c)
   (A B C)

Но она также позволяет указывать какие части цитирования должны быть вычислены. Эти части указываются с помощью запятой:
::

   > (defvar a 10)
   A
   > `(a b c ,a)
   (A B C 10)

Запятая может стоять перед выражением, которое вычистяется
::

   > (defvar a 10)
   A
   > `(a b c ,(+ 1 a))
   (A B C 11)

Запятая-at служит для того, чтобы подставить список (результат вычисления выражения внутри запятой-at должен быть списком):
::

   > (defvar a '(1 2 3))
   A
   > `(,a ,@a)
   ((1 2 3) 1 2 3)

Можно посмотреть результат макроподстановки с помощью функции macroexpand:
::

   > (macroexpand '(if (= 1 1) 2 3))
   (COND ((= 1 1) 2) (T 3))
