\section{Анализ предметной области}

\subsection{Понятие интерпретатора}

Интерпретатор языка программирования -- это программа типа транслятор, считывающая программный код, написанный на определённом языке программирования, по одной инструкции или группе инструкций и немедленно исполняющая их в соответствии с синтаксисом и семантикой языка.

В сравнении с компилятором, анализирующим и единоразово преобразующим весь исходный код программы в машинный код перед её выполнением, и JIT-компилятором, выполняющим компиляцию во время исполнения, интерпретатор в реальном времени анализирует и выполняет код по одной инструкции, сначала преобразуя её во внутреннее представление и затем в машинный код \cite{e27}.



\subsection{Строение интерпретатора}

\subsubsection{Лексический анализатор и лексема}
Всё начинается с лексемы \cite{e21} — символа или набора символов, минимально значимой единицы исходного кода, которую интерпретатор может распознать и обработать. Лексемы включают в себя ключевые слова, идентификаторы, константы, символы и операторы. Они служат для разделения кода на части, которые затем будут преобразованы во внутреннее представление интерпретатора и выполнены им.

С применением лексического анализатора лексемы постепенно перерабатываются в токены \cite{e21}.

Токен -- та же лексема, но представленная специальным значением или имеющая дополнительный атрибут, что позволит синтаксическому анализатору идентифицировать её или узнать о ней дополнительную информацию. Например, тип лексемы -- число, строка и так далее.

Лексический анализ (токенизация) -- формирование токенов на основе исходного кода программы, таких как ключевые слова, идентификаторы, операторы, литералы и так далее. 

Лексический анализатор (ЛА) распознаёт лексемы в исходном коде программы, пропуская пустоты (пробелы, переводы строк) \cite{e20}, определяет особенности лексемы и из полученных данных формирует токен, который будет передан следующим компонентам интерпретатора. Считывание текста программы из потока ввода производится до тех пор, пока не встретится зарезервированный символ, после чего начинается формирование токена. Либо, если в синтаксисе языка предусмотрены односимвольные лексемы, то формирование происходит сразу. Также лексический анализатор берёт на себя задачу по выявлению символов, не являющихся частью синтаксиса языка в анализируемом контексте, и при обнаружении таковых выводит на экран соответствующую ошибку.



\subsubsection{Синтаксический анализатор, синтаксис языка программирования и внутреннее представление}

Следующим этапом работы интерпретатора является анализ полученных от лексического анализатора токенов и преобразование их во внутреннее представление интерпретатора для передачи следующим его компонентам.

Внутреннее представление -- это проекция выражений и конструкций языка программирования внутри интерпретатора. Им определяется как интерпретатор хранит данные и оперирует ими во время выполнения программы \cite{e19}.

Синтаксис языка программирования представляет собой набор правил для написания языковых выражений и конструкций, которые будут интерпретированы и выполнены компилятором или интерпретатором соответствующего языка ровно таким образом, каким это описано в спецификации языка.

Синтаксис определяет как символы образуют лексемы и как они комбинируются для формирования языковых конструкций и выражений, которые затем интерпретируются компьютером. Он определяет порядок операций, приоритет операторов, структуру программы, а также способы объявления переменных, функций, ветвлений и других конструкций, составляющих структуру программного кода. При отсутствии ошибок в реализации интерпретатора, несоблюдение или неполное понимание синтаксических правил может привести как к ошибкам, так и к неожиданному с точки зрения разработчика поведению.

Синтаксический анализатор (СА) отвечает за анализ синтаксиса программного кода, проверку его на соответствие правилам и построение в соответствии с синтаксисом языка программирования объектов внутреннего представления интерпретатора на основе полученного от лексического анализатора токена.

Если обнаруживается ошибка в синтаксисе программы, то этот анализатор выводит на экран соответствующее сообщение об ошибке и прекращает дальнейшую обработку программы. Такой ошибкой может быть, например, отсутствующая закрывающая скобка или ключевое слово, которое отсутствует в языке программирования.



\subsubsection{Исполнитель}

После успешного завершения синтаксического анализа и получения сформированных СА объектов, они передаются на исполнение.

Исполнение -- выполнение кода, представленного во внутреннем формате, пошаговое выполнение инструкций программы, обрабатывая операторы и вычисляя значения выражений.

В процессе исполнения интерпретатор манипулирует теми объектами, которые ранее были сформированы синтаксическим анализатором из токенов. Именно на этапе исполнения происходят все вычисления и работа с данными программы -- объявление переменных и задание им значений, вызов функций и так далее.

Таким образом, исполнитель, выполняющий исполнение внутреннего представления, можно назвать ключевым компонентом интерпретатора.


\subsubsection{Сборщик мусора}
Сборщик мусора — это компонент интерпретатора, который отслеживает неиспользуемые объекты внутреннего представления и освобождает занятую ими память \cite{e17}.

Неиспользуемыми объектами считаются те, которых нельзя достичь перемещаясь по дереву ссылок от активных объектов.

В зависимости от целей, поставленных разработчиком, наличие сборщика мусора может быть как положительной, так и отрицательной чертой языка программирования. Если вопрос занимаемой программой ОЗУ не является особенно важным, его наличие освобождает программиста от необходимости в ручном режиме выделять и освобождать память, что значительно упрощает процесс разработки, сводит к минимуму потенциальные уязвимости и проблематику утечек памяти в разрабатываемом ПО.


\subsection{Функциональное программирование}

Функциональное программирование -- это парадигма разработки ПО, где функции выступают в роли основного элемента конструкции программ и могут в качестве аргументов принимать другие функции \cite{e9}. Тем самым выстраивается структура, основанная на функциях, их взаимодействии и композиции.

Также в этой парадигме принята идея о том, что по возможности и если то будет разумным, стоит придерживаться написания \quotes{чистых} функций -- функций, не имеющих побочных эффектов и при вызове с одними и теми же аргументами всегда возвращающих одинаковый результат, без изменения состояния программы или лексического окружения.

Но, для поддержания чистоты функций, стоит по возможности следовать концепции неизменности данных, суть которой заключается в отказе от изменения каких-либо уже сформированных данных. Таким образом, предпочтение отдаётся написанию функций, которые не изменяют исходные данные, а формируют и возвращают новые на основе исходных. Оба эти подхода способствуют формированию модульного, предсказуемого и надёжного кода, что в последствии упростит отладку и тестирование программы.

Основу для реализации функциональной парадигмы составляют функции высшего порядка и лямбда-функции.

Функции, имеющие возможность принимать в качестве аргументов другие функции, тем самым формируя цепи функциональных преобразований, где одни функции могут быть переданы и манипулируемы подобно другим объектам языка вроде списков или чисел, называются функциями высшего порядка \cite{e12}. Умелое использование таких возможностей для создания обобщённых функций, применяемых для выполнения более широкого спектра условий, приводит к повышению модульности, переиспользуемости и выразительности кода.

Лямбда-функции (анонимные функции) -- это безымянные функции высшего порядка, которые используют в качестве аргумента для передачи другим функциям, возврата функции из функции или одноразового применения, что позволяет без необходимости не занимать пространство имён.

\subsection{Метапрограммирование}
Метапрограммирование — это вид программирования, который связан с созданием программ, генерирующих другие программы как результат своей работы, или программ, изменяющих себя во время выполнения. В функциональном программировании такой подход используется часто, потому как функции сами являются данными и могут быть переданы как аргументы другим функциям, создавать новые функции и изменять собственные тела.

Метапрограммирование реализуется системой макросов \cite{e6}, позволяющей разработчику создавать новые языковые конструкции, генерируя, изменяя и делая динамическим код программы .

Макросы -- это функции, генерирующие код, который в последствии заменит код генерации. Они работают на этапе компиляции или интерпретации, позволяя трансформировать исходный код перед его выполнением. Макросы позволяют создавать собственные синтаксические конструкции и расширять язык, что открывает для разработчика почти безграничные возможности по адаптации языка под свои нужды и создания адаптивного ПО. 

Например, макросы можно применить для включения или исключения частей кода в зависимости от условий запуска и особенностей компьютера, на котором происходит запуск. Помимо прочего, использование макросов может ускорить работу программ за счёт возможности один раз сгенерировать функцию с определёнными аргументами, а после переиспользовать её, без необходимости каждый раз заново вызывать функцию с одними и теми же аргументами.

\subsection{Язык программирования Lisp}

Функциональный язык программирования с уклоном в сферу разработки искусственного интеллекта, один из самых старых используемых и теперь языков — Lisp, появившийся в 1958 трудами учёного Джона Маккарти.

Инновационность языка состояла в том, что его автор спроектировал удобный инструментарий для работы со списками и символами, что было очень востребовано при решении задач обработки естественного языка и символьной логики \cite{e1}. Список в Lisp -- главный элемент, потому как весь программный код на нём в конечном итоге состоит из множества списков. Хотя в первое время Lisp использовался только для решения неширокого перечня задач в сфере искусственного интеллекта, спустя чуть более чем десять лет с момента создания он всё же получил широкую известность и на долгое время стал центральным в этой сфере.

Кроме того, наличие успешной реализации системы макросов, составляющей в нём основу парадигмы метапрограммирования, в сумме с другими преимуществами сделала его востребованным для разработки предметно-ориентированных языков \cite{e11}. Суть языков такого типа заключается в их адаптированности под конкретные задачи и способы применения, способствуя таким образом удобству написания программного кода.

Также примечательным является, что сборщик мусора и возможность использовать функции подобно данным впервые были введены именно в этом языке. 

Постепенно оригинальный Lisp отходил на второй план и известность перенимали его диалекты. На данный момент одним из наиболее используемых является Common Lisp — диалект, ставящий своей целью объединение удачных решений других разновидностей оригинального языка, чтобы сформировать мультипарадигменную, очень гибкую и достаточно широкую в плане способов применения и базовой функциональности вариацию.