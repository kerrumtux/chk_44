\section{Техническое задание}
\subsection{Основание для разработки}

Полное наименование системы: \quotes{Интерпретатор функционального языка программирования с поддержкой метапрограммирования}.

Основанием для разработки программы является приказ ректора ЮЗГУ от «15» апреля 2024 г. №1779-с «Об утверждении тем выпускных квалификационных работ».

\subsection{Цель и назначение разработки}

Цель этой работы -- разработка программной системы, позволяющей сокращение размера исходного кода программ за счёт метапрограммирования.

Для достижения этой цели было принято решение разработать интерпретатор функционального языка программирования с поддержкой метапрограммирования. Основной задачей разработки является разработка программного обеспечения, способного анализировать и исполнять программы, написанные на функциональном языке программирования, а также обеспечивать возможности генерации и изменения кода на этом языке с использованием инструментов метапрограммирования.

Интерпретатор, созданный в рамках данной работы, должен иметь все ключевые функции, обеспечивающие поддержку парадигм метапрограммирования и функционального программирования. Для их реализации будет разработан простой и минималистичный функциональный язык программирования, называемый \quotes{демонстрационный язык программирования} (ДЯП), поддерживающий метапрограммирование.

Таким образом, интерпретатор сможет работать с  числами, строками, переменными, функциями, лямбда-выражениями, макросами и другими необходимыми конструкциями, обеспечивающими разработчику возможность использовать метапрограммирование для создания адаптивных и реплицируемых приложений.

Задачами данной разработки являются:
\begin{itemize}
	\item провести анализ предметной области;
	\item спроектировать функциональный язык программирования с поддержкой метапрограммирования, являющийся подмножеством языка \quotes{Common Lisp};
	\item спроектировать интерпретатор этого языка;
	\item выбрать технологии и методики для реализации интерпретатора;
	\item реализовать интерпретатор средствами языка программирования \quotes{C} и ОС \quotes{GNU/Linux}.
\end{itemize}


\subsection{Описание разрабатываемого языка}

Разрабатываемый язык является подмножеством языка программирования \quotes{Common Lisp} и сосредотачивается на реализации его базовых возможностей по работе с данными и метапрограммирования. Потому, он будет иметь функциональность для работы с переменными, функциями, лямбда-выражениями, функциями высшего порядка, числами, строками, символами, списками и массивами. Введутся базовые функции для обработки данных, включая операции сложения чисел, выделения подстрок из строк, определения имени символа по символьному объекту и другие, реализующие минимально необходимые возможности для манипуляции данными. Также будет включена система макросов как основной элемент реализации метапрограммирования.

\subsubsection{Алфавит языка}
Алфавит языка программирования -- это перечень символов, допустимых к использованию для записи синтаксических конструкций этого языка \cite{e4}. Символом может быть как буква, цифра или знак препинания, так и любой другой знак, рассматриваемый как неделимый элемент языка.

Алфавит разработанного языка включает:
\begin{itemize}
	\item латинские символы верхнего и нижнего регистра;
	\item римские цифры;
	\item символы, зарезервированные под описание конструкций языка, перечисленные через пробел: ' ` , . '' \#;
	\item другие символы, перечисленные через пробел: + - * / = \_ \& | < >.
\end{itemize}

\subsubsection{Лексемы, распознаваемые лексическим анализатором}

Список наименований лексем, распознаваемых лексическим анализатором, а также их символьное представление или пример:
\begin{itemize}
	\item десятичное и шестнадцатеричное целое число: 10, 0xFFAA;
	\item вещественное число: 1.34;
	\item символ: A;
	\item цитата: ';
	\item квазицитата: `;
	\item запятая: ,;
	\item запятая-at: ,@;
	\item решётка: \#;
	\item левая скобка: (;
	\item правая скобка: );
	\item точка: .;
	\item строка: \quotes{a b c v ddd};
	\item неизвестный объект -- объект, который ЛА не смог определить;
	\item конец потока.
\end{itemize}

Помимо этого, для удобства разработчика, синтаксисом языка предусмотрена возможность добавлять в код комментарии. Комментарий начинается со знака ‭\quotes{;} и заканчивается переносом строки.

Символ \quotes{\textbackslash} используется для экранирования.


\subsubsection{Типы данных}
Для языка программирования были определены шесть фактических типов данных и два псевдотипа:
\begin{itemize}
	\item число -- десятичные и шестнадцатеричные числа, размер которых ограничен 28 битами (от -134217728 до 134217727). Например: 10, 0xFFAA;
	
	\item большое число -- число, для хранения которого выделено 32 бит. Например: 134217728;
	
	\item строка -- произвольный набор алфавитных символов, задающийся в двойных кавычках. Например: \quotes{ab 12 /};
	
	\item символ -- именованный нечувствительно к регистру объект, который может указывать на некоторое значение -- число, лямбда-выражение, макрос, строку, массив, список или функцию. Имя символа должно начинаться с буквы или разрешенного символа и может содержать буквы, цифры, символы. Таким образом, переменные, функции и другие объекты языка, к которым можно обращаться по имени, являются символами, содержащими указатель на объект с данными, заданными для этого символа. Пример символа: 'A;
	
	\item точечная пара (список) -- это хранилище, содержащее только два элемента, называемые левым и правым. Пара носит название точечной, так как в синтаксисе эта конструкция представляет собой два элемента, разделённые точкой, обрамлённые в круглые скобки. Элементом пары может быть другая пара, что позволяет создавать списки, выстроенные из цепи точечных пар. Правый элемент последнего элемента такой цепи указывает на специальное значение nil. Например: ('a . (4 . nil));
	
	\item массив -- хранилище с прямым доступом к элементам (можно обращаться по индексу), содержащее ноль или более атомов, разделенных пустотами и заключённых в круглые скобки, перед открывающей ставится \#. Массивы могут содержать в себе другие массивы. Пример: \#(3 6 9).
\end{itemize}

Для идентификации типов в интерпретаторе будет использоваться перечисление, содержащее следующие значения:
\begin{itemize}
	\item NUMBER: число;
	\item BIGNUMBER: большое число;
	\item SYMBOL: символ;
	\item PAIR: точечная пара (список);
	\item STRING: строка;
	\item ARRAY: массив.
\end{itemize}

S-выражение -- это основной элемент синтаксиса языка, который может быть атомом или списком. S-выражения нечувствительны к регистру. Все инструкции в ДЯП являются s-выражениями, из чего следует, что программный код представляет собой множество s-выражений \cite{e10}.

Атом -- псевдотип, специальное название для обозначения примитивных объектов данных, которые не разбиваются на составляющие: символы, числа и строки.

Для обозначения \quotes{истинного} и \quotes{ложного} используются зарезервированные объекты-символы \quotes{T} и \quotes{NIL} соответственно.

\subsubsection{Функции и лямбда-выражения}

В языке программировании применяются функции и лямбда-выражения.

Функция представлена в виде списка, содержащего символ, имя которого соответствует имени функции, список аргументов и тело функции.

Для объявления новой функции используется функция defun, имеющая следующий синтаксис:

\quotes{(defun name (p \textsubscript 1 ... p \textsubscript n) e)}, где name -- имя объявляемой функции, p \textsubscript 1 ... p \textsubscript n -- параметры функции, e -- тело функции.

Вызов функции -- список, где первый элемент это имя функции, а последующие являются её аргументами.

Синтаксис вызова функции:

\quotes{(name a \textsubscript 1 ... a \textsubscript n)}, где name -- имя вызываемой функции, а a \textsubscript 1 ... a \textsubscript n -- передаваемые функции аргументы.

Лямбда-выражения объявляются идентично функциям, но вместо функции defun используется lambda и, так как лямбда-выражения безымянны, имя не задаётся.

Для вызова лямбда-выражения необходимо создать список, где первым элементом будет само лямбда-выражение, а a \textsubscript 1 ... a \textsubscript n -- передаваемые выражению аргументы: 

\quotes{((lambda (p \textsubscript 1 ... p \textsubscript n) e) a \textsubscript 1 ... a \textsubscript n)}.

При вызове, сначала вычисляются все аргументы a \textsubscript 1 ... a \textsubscript n. Затем каждому параметру p \textsubscript 1 ... p \textsubscript n ставится в соответствие вычисленное значение аргументов a \textsubscript 1 ... a \textsubscript n. После этого вычисляется выражение e, содержащее параметры, вместо которых будут подставлены их значения. Например:

\begin{lstlisting}[language=Lisp, frame=none]
< ((lambda (x y) (cons x (cdr y))) 'z '(a b c))
> (Z B C)
\end{lstlisting}

Это лямбда-выражение с помощью функции cons создаёт список, состоящий из значения аргумента x и обрезанного со второго элемента с помощью cdr списка y. Результатом выполнения этого кода будет новый список -- \quotes{(Z B C)}.

Также имеется возможность объявить параметр функции таким образом, чтобы он собирал все аргументы, начинающиеся с соответствующего ему, в список. Для этого перед таким параметром через пробел помещается конструкция \quotes{\&rest}. Например:

\begin{lstlisting}[language=Lisp, frame=none]
< (defun test (a b &rest c) (+ a (+ b (car c))))
< (test 1 2 3 4 5)
> 6
\end{lstlisting}

В результате в переменную \quotes{c} попадут числа 3, 4 и 5. Так как \quotes{a} равна 1, \quotes{b} равна 2, а \quotes{car c} вернёт \quotes{3} - вычисленное значение - 6. Такая возможность позволяет разрабатывать функции с динамическим числом переменных, что имеет большое значение в разработке адаптивного ПО.

Функции и лямбда-выражения могут быть получены и переданы в качестве аргументов или возвращены из функции и лямбда-выражения, как и необходимо в функциональной парадигме программирования. Иначе говоря, реализована поддержка функций высшего порядка.

\subsubsection{Макросы}

В ДЯП для создания макросов применяется функция defmacro, а также операторы quote, backquote и comma.

Функция defmacro имеет следующий синтаксис:
\quotes{(defmacro name (a \textsubscript 1 ... a \textsubscript n) e)}, где name -- имя макроса, a \textsubscript 1 ... a \textsubscript n -- параметры макроса, e -- тело макроса.

Пример использования:

\begin{enumerate}
	\item Создам макрос, задающий шаблон для генерации выражения:
	
	\begin{lstlisting}[language=Lisp, frame=none]
	(defmacro test (var val) (list 'defvar var val))}
	\end{lstlisting}
	
	При вычислении этот макрос заменится списком, первым элементом которого будет символ defvar для объявления переменной, а последующими -- переданные при вызове макроса аргументы:
	
	\begin{lstlisting}[language=Lisp, frame=none]
	(defvar var val)}
	\end{lstlisting}
	
	Для того, чтобы посмотреть что собой будет представлять вычисленный макрос с переданными ему аргументами, имеется функция \quotes{macroexpand}, куда вызов макроса передаётся в виде списка, на который применено цитирование:
	
	\begin{lstlisting}[language=Lisp, frame=none]
	< (macroexpand '(test a 2))
	> (defvar a 2)
	\end{lstlisting}
	
	\item Вызову макрос с символом \quotes{abc} и числом 100 в качестве аргумента. При вызове происходит вычисление тела макроса (развертывание макроса):
	
	\quotes{(test abc 100)} преобразуется в \quotes{(defvar abc 100)}.
	
	\item Получившееся выражение вычисляется. Список расценивается как код, который определяет переменную и присваивает ей значение:
	
	\begin{lstlisting}[language=Lisp, frame=none]
	(defvar abc 100)
	\end{lstlisting}
\end{enumerate}

По итогу был создан макрос test, объявляющий переменную с именем, переданным ему в качестве первого аргумента, и значением в качестве второго.

Кавычки (') -- символ, используемый для реализации цитирования -- предотвращения вычисления выражения. Например, выражение (* 2 2) будет автоматически вычислено и даст 4, в то время как '(* 2 2) будет восприниматься как список символов.

Но для предоставления по-настоящему широкого спектра возможностей для разработчика, необходимо реализовать инструментарий, позволяющий выполнять частичные вычисления -- квазицитирование.

Для того будут использоваться символы обратной кавычки \quotes{`} и запятой \quotes{,}. Обратная кавычка будет указывать на то, что выражение содержит вычисляемые элементы, а запятая укажет на них.

Пример использования:
\begin{lstlisting}[language=Lisp, frame=none]
< (defvar b 12) (print `(+ a ,b))

> (+ A 12)
\end{lstlisting}

Таким образом, \quotes{+} и \quotes{a} были восприняты интерпретатором как символы и остались невычисленными, а \quotes{b} заменён значением соответствующей переменной.

Также необходимой является функция развёртывания списков, обозначаемая лексемой \quotes{,@} (запятая-собачка). Если поместить её перед списком, после вычисления скобки, обрамляющие список, будут удалены и элементы списка предстанут самостоятельными элементами, вне его. Например:

\quotes{(funcrun ,@varlist)}, где funcrun - некоторая функция, а varlist - список \quotes{(1 2 3)}.

После вычисления будет преобразовано в:

\quotes{(funcrun 1 2 3)}.

Так у разработчика появляется ещё одна возможность, упрощающая процесс манипуляции списками.

Кавычка, обратная кавычка, запятая и запятая-собачка действуют на вычисление только того выражения, перед которым стоят.


\subsection{Требования к программной системе}

\subsubsection{Требования к данным программной системы}
Программная система должна принимать на вход файл с кодировкой \quotes{UTF-8}, содержащий программный код на ДЯП.

\subsubsection{Требования к программному обеспечению}
Для реализации программной системы должны быть использованы: язык программирования \quotes{C}, реализация стандартной библиотеки языка - \quotes{glibc}.

Для сборки ПС требуется ОС семейства \quotes{GNU/Linux}, поддерживающая компилятор GCC версии \quotes{10.1} или новее.

\subsubsection{Требования к аппаратному обеспечению}
Для работы ПС необходим компьютер с архитектурой центрального процессора \quotes{x86} и свободной для использования пользовательскими процессами оперативной памятью от 64 Мб.

\subsection{Требования к оформлению документации}

Разработка программной документации и программного изделия должна производиться согласно ГОСТ 19.102-77 и ГОСТ 34.601-90. Единая система программной документации.
